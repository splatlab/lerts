#define _GNU_SOURCE
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <sys/time.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>
#include <openssl/rand.h>

#include <zipf.h>
#include <gqf.h>

#ifndef  USE_MYRANDOM
#define RFUN random
#define RSEED srandom
#else
#define RFUN myrandom
#define RSEED mysrandom

static unsigned int m_z = 1;
static unsigned int m_w = 1;
static void mysrandom (unsigned int seed) {
	m_z = seed;
	m_w = (seed<<16) + (seed >> 16);
}

static long myrandom()
{
	m_z = 36969 * (m_z & 65535) + (m_z >> 16);
	m_w = 18000 * (m_w & 65535) + (m_w >> 16);
	return ((m_z << 16) + m_w) % 0x7FFFFFFF;
}
#endif


uint64_t tv2msec(struct timeval tv)
{
	return tv.tv_sec * 1000 + tv.tv_usec / 1000;
}

int cmp_uint64_t(const void *a, const void *b)
{
	const uint64_t *ua = (const uint64_t*)a, *ub = (const uint64_t *)b;
	return *ua < *ub ? -1 : *ua == *ub ? 0 : 1;
}

#if 1
static float tdiff (struct timeval *start, struct timeval *end) {
	return (end->tv_sec-start->tv_sec) +1e-6*(end->tv_usec - start->tv_usec);
}

uint64_t aes_hash2(uint64_t x)
{
	const uint64_t round_keys[32] =
	{ // These were generated by hashing some randomly chosen files on my laptop
		0x795e15dc8136095f, 0x562371660e56b023,
		0x086bb301d2fb5e87, 0x1fe74f801c68d829,
		0x38a19379fd013357, 0x4a7ef2fca0f840f5,
		0x7d2a08bc58553aef, 0x092cfe1997ab8b53,
		0xd18a0c07dac143d4, 0x64e345ef125a576c,
		0x82807902d8211a1f, 0x6985dc4ddcdaf85d,
		0x2214ff750cf750af, 0xb574b4138eb8a37e,
		0x83e11205e8050dd5, 0x2d62b24118df61eb,
		0x8a16453f8f6b6fa1, 0x260c9e8491474d4f,
		0x06eb44d6042ca8ae, 0x43efbd457306b135,
		0xbfcb7ac89f346686, 0xd00362f30651d0d0,
		0x016d3080768968d5, 0x74b4c2e46ef801de,
		0xf623864a4396fe74, 0x9fc26ea69dad6067,
		0xd0eb2f4e08564d99, 0x408b357725ae0297,
		0xd19efb8e82d22151, 0x58c5ead61b7ecc15,
		0x14e904bc8de1c705, 0x1ef79cd4f487912d
	};
	__uint128_t *rks = (__uint128_t *)round_keys;
	uint64_t output;

	asm("movq       %[input],       %%xmm15;"
			"pxor       %[round_keys0], %%xmm15;"
			"aesenc     %[round_keys1], %%xmm15;"
			"aesenc     %[round_keys2], %%xmm15;"
			"aesenc     %[round_keys3], %%xmm15;"
			"aesenc     %[round_keys4], %%xmm15;"
			"aesenc     %[round_keys5], %%xmm15;"
			"aesenc     %[round_keys6], %%xmm15;"
			"aesenc     %[round_keys7], %%xmm15;"
			"aesenc     %[round_keys8], %%xmm15;"
			"aesenc     %[round_keys9], %%xmm15;"
			"aesenclast %[round_keysa], %%xmm15;"
			"vmovq      %%xmm15,        %[output]"
			: [output] "=irm" (output)
			: [input] "irm" (x),
			[round_keys0] "m" (rks[0]),
			[round_keys1] "m" (rks[1]),
			[round_keys2] "m" (rks[2]),
			[round_keys3] "m" (rks[3]),
			[round_keys4] "m" (rks[4]),
			[round_keys5] "m" (rks[5]),
			[round_keys6] "m" (rks[6]),
			[round_keys7] "m" (rks[7]),
			[round_keys8] "m" (rks[8]),
			[round_keys9] "m" (rks[9]),
			[round_keysa] "m" (rks[10])
				 : "xmm15"
					 );

	return output;
}


static uint64_t* test1 (long N, long gencount, double s) {
	int i;
	uint32_t *counts;
	uint64_t *elems;
	struct timeval a,b,c;
	printf("Generating %ld elements in universe of %ld items with characteristic exponent %f\n",
				 gencount, N, s);
	gettimeofday(&a, NULL);
	ZIPFIAN z = create_zipfian(1, N, RFUN);
	counts = calloc(N, sizeof(counts));
	elems = calloc(gencount, sizeof(elems));

	gettimeofday(&b, NULL);
	printf("Setup time    = %0.6fs\n", tdiff(&a, &b));
	for (i=0; i<gencount; i++) {
		long g = zipfian_gen(z);
		assert(0<=g && g<N);
		counts[g]++;
		elems[i] = g;
	}
	gettimeofday(&c, NULL);
	double rtime = tdiff(&b, &c);
	printf("Generate time = %0.6fs (%f per second)\n", rtime, gencount/rtime);
	if (0) {
		for (i=0; i<N; i++) {
			printf("%4.1f (%4.1f)\n", counts[0]/(double)counts[i], i/(counts[0]/(double)counts[i]));
			//	printf("%d ", counts[i]);
		}
		printf("\n");
	}
	destroy_zipfian(z);
	return elems;
}
#endif

int main (int argc __attribute__((__unused__)), char *argv[] __attribute__((__unused__))) {
	QF cf;
	QFi cfi;
	int qbits = atoi(argv[1]);
	uint64_t nslots = (1ULL << qbits);
	uint64_t nvals = nslots*3;
	uint64_t *vals;
	uint64_t *othervals;
	unsigned int i, j, exp;
	FILE *fp_insert = fopen("../vldb16/data/gqf-26-zipf-distinct-insert.txt", "w");
	FILE *fp_exit_lookup = fopen("../vldb16/data/gqf-26-zipf-distinct-exists-lookup.txt", "w");
	FILE *fp_false_lookup = fopen("../vldb16/data/gqf-26-zipf-distinct-false-lookup.txt", "w");
	uint64_t distinct_inserts[20];
	uint64_t occupied_slots[20];
	struct timeval tv_insert[40];
	struct timeval tv_exit_lookup[40];
	struct timeval tv_false_lookup[40];
	uint64_t fps = 0;

	qf_init(&cf, nslots, qbits + BITS_PER_SLOT, 0);
	// printf("%u %u %ld\n", cf.nremainder_bits, cf.ncounter_bits, cf.range);	

#if 1
	{
		struct timeval tv;
		gettimeofday(&tv, NULL);
		RSEED(tv.tv_sec + tv.tv_usec);
	}

	vals = test1(nvals, nvals, 1.5);
	for (i = 0; i < nvals; i++) {
		vals[i] = aes_hash2(vals[i]) % cf.range;
	}

	othervals = calloc(nvals, sizeof(othervals[0]));
	RAND_pseudo_bytes((unsigned char *)othervals, sizeof(*othervals) * nvals);
	for (i = 0; i < nvals; i++)
		othervals[i] = othervals[i] % cf.range;

	for (exp = 0; exp < 40; exp += 2) {
		i = (exp/2)*(nvals/20);
		j = ((exp/2) + 1)*(nvals/20);
		gettimeofday(&tv_insert[exp], NULL);
		for (;i < j; i++) {
			qf_insert(&cf, vals[i], 0, 1);
//			printf("Inserting 0x%lx\n", vals[i]);
//			qf_dump(&cf);
		}
		distinct_inserts[exp/2] = cf.ndistinct_elts;
		occupied_slots[exp/2] = cf.noccupied_slots;
		gettimeofday(&tv_insert[exp+1], NULL);

		i = (exp/2)*(nvals/20);
		gettimeofday(&tv_exit_lookup[exp], NULL);
		for (;i < j; i++) {
			if (!qf_count_key_value(&cf, vals[i], 0)) {
				fprintf(stderr, "Failed lookup for 0x%lx\n", vals[i]);
				abort();
			}
		}
		gettimeofday(&tv_exit_lookup[exp+1], NULL);

		i = (exp/2)*(nvals/20);
		gettimeofday(&tv_false_lookup[exp], NULL);
		for (;i < j; i++) {
			fps += qf_count_key_value(&cf, vals[i], 0);
		}
		gettimeofday(&tv_false_lookup[exp+1], NULL);
	}

#else  
	vals = calloc(nvals, sizeof(vals[0]));
	RAND_pseudo_bytes((unsigned char *)vals, sizeof(*vals) * nvals);
	for (i = 0; i < nvals; i++)
		vals[i] = (1 * vals[i]) % cf.range;

	othervals = calloc(nvals, sizeof(othervals[0]));
	RAND_pseudo_bytes((unsigned char *)othervals, sizeof(*othervals) * nvals);
	for (i = 0; i < nvals; i++)
		othervals[i] = othervals[i] % cf.range;

	for (exp = 0; exp < 40; exp += 2) {
		i = (exp/2)*(nvals/20);
		j = ((exp/2) + 1)*(nvals/20);
		gettimeofday(&tv_insert[exp], NULL);
		for (;i < j; i++) {
			insert(&cf, vals[i]);
		}
		gettimeofday(&tv_insert[exp+1], NULL);

		i = (exp/2)*(nvals/20);
		gettimeofday(&tv_exit_lookup[exp], NULL);
		for (;i < j; i++) {
			if (!may_contain(&cf, vals[i])) {
				fprintf(stderr, "Failed lookup for 0x%lx\n", vals[i]);
				abort();
			}
		}
		gettimeofday(&tv_exit_lookup[exp+1], NULL);

		i = (exp/2)*(nvals/20);
		gettimeofday(&tv_false_lookup[exp], NULL);
		for (;i < j; i++) {
			fps += may_contain(&cf, othervals[i]);
		}
		gettimeofday(&tv_false_lookup[exp+1], NULL);
	}
#endif

	fprintf(fp_insert, "x_0    y_0\n");
	for (exp = 0; exp < 20; exp++) {
		printf("%ld %f\n",
				distinct_inserts[exp], ((float)occupied_slots[exp]/(float)nslots)*100);
	}

	fprintf(fp_insert, "x_0    y_0\n");
	for (exp = 0; exp < 40; exp += 2) {
		fprintf(fp_insert, "%f %f\n",
						((float)distinct_inserts[exp/2]/(float)nslots), 0.001 * (nvals/20)/(tv2msec(tv_insert[exp+1]) - tv2msec(tv_insert[exp])));
	}
	printf("\n Insert Performance written");
	fprintf(fp_exit_lookup, "x_0    y_0\n");
	for (exp = 0; exp < 40; exp += 2) {
		fprintf(fp_exit_lookup, "%f %f\n",
						((float)distinct_inserts[exp/2]/(float)nslots), 0.001 * (nvals/20)/(tv2msec(tv_exit_lookup[exp+1]) - tv2msec(tv_exit_lookup[exp])));
	}
	printf("\n Existing Lookup Performance written");
	fprintf(fp_false_lookup, "x_0    y_0\n");
	for (exp = 0; exp < 40; exp += 2) {
		fprintf(fp_false_lookup, "%f %f\n",
					((float)distinct_inserts[exp/2]/(float)nslots), 0.001 * (nvals/20)/(tv2msec(tv_false_lookup[exp+1]) - tv2msec(tv_false_lookup[exp])));
	}
	printf("\n False Lookup Performance written");


	/* Adding code for iterator */
	/*qf_iterator(&cf, &cfi, 0);*/
	/*do {*/
		/*uint64_t key, value, count;*/
		/*qfi_get(&cfi, &key, &value, &count);*/
		/*if (count > 100)*/
			/*printf("\n0x%lx %ld", key, count);*/
	/*} while(!qfi_next(&cfi));*/


	/*
		 printf("Insert:          %f ins/sec\n"
		 "Lookup existing: %f lookups/sec\n"
		 "Lookup random:   %f lookus/sec\n",
		 1000.0 * nvals / (tv2msec(tv[1]) - tv2msec(tv[0])),
		 1000.0 * nvals / (tv2msec(tv[2]) - tv2msec(tv[1])),
		 1000.0 * nvals / (tv2msec(tv[3]) - tv2msec(tv[2])));
		 */

	printf("\nFP rate: %f (%lu/%lu)\n", 1.0 * fps / nvals, fps, nvals);

	fclose(fp_insert);
	fclose(fp_exit_lookup);
	fclose(fp_false_lookup);

	return 0;
}
