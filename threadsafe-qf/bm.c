/*
 * =====================================================================================
 *
 *       Filename:  bm.c
 *
 *    Description:  
 *
 *        Version:  1.0
 *        Created:  05/18/2015 08:54:53 PM
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Prashant Pandey (ppandey@cs.stonybrook.edu),
 *   Organization:  
 *
 * =====================================================================================
 */

#include <time.h>
#include <sys/time.h>
#include <sys/types.h>
#include <openssl/rand.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#include "zipf.h"

//#include "qf_wrapper.h"
#include "gqf_wrapper.h"
//#include "cf_wrapper.h"
//#include "bf_wrapper.h"

#ifndef  USE_MYRANDOM
#define RFUN random
#define RSEED srandom
#else
#define RFUN myrandom
#define RSEED mysrandom

static unsigned int m_z = 1;
static unsigned int m_w = 1;
static void mysrandom (unsigned int seed) {
	m_z = seed;
	m_w = (seed<<16) + (seed >> 16);
}

static long myrandom()
{
	m_z = 36969 * (m_z & 65535) + (m_z >> 16);
	m_w = 18000 * (m_w & 65535) + (m_w >> 16);
	return ((m_z << 16) + m_w) % 0x7FFFFFFF;
}
#endif

static float tdiff (struct timeval *start, struct timeval *end) {
	return (end->tv_sec-start->tv_sec) +1e-6*(end->tv_usec - start->tv_usec);
}

uint64_t aes_hash2(uint64_t x)
{
	const uint64_t round_keys[32] =
	{ // These were generated by hashing some randomly chosen files on my laptop
		0x795e15dc8136095f, 0x562371660e56b023,
		0x086bb301d2fb5e87, 0x1fe74f801c68d829,
		0x38a19379fd013357, 0x4a7ef2fca0f840f5,
		0x7d2a08bc58553aef, 0x092cfe1997ab8b53,
		0xd18a0c07dac143d4, 0x64e345ef125a576c,
		0x82807902d8211a1f, 0x6985dc4ddcdaf85d,
		0x2214ff750cf750af, 0xb574b4138eb8a37e,
		0x83e11205e8050dd5, 0x2d62b24118df61eb,
		0x8a16453f8f6b6fa1, 0x260c9e8491474d4f,
		0x06eb44d6042ca8ae, 0x43efbd457306b135,
		0xbfcb7ac89f346686, 0xd00362f30651d0d0,
		0x016d3080768968d5, 0x74b4c2e46ef801de,
		0xf623864a4396fe74, 0x9fc26ea69dad6067,
		0xd0eb2f4e08564d99, 0x408b357725ae0297,
		0xd19efb8e82d22151, 0x58c5ead61b7ecc15,
		0x14e904bc8de1c705, 0x1ef79cd4f487912d
	};
	__uint128_t *rks = (__uint128_t *)round_keys;
	uint64_t output;

	asm("movq       %[input],       %%xmm15;"
			"pxor       %[round_keys0], %%xmm15;"
			"aesenc     %[round_keys1], %%xmm15;"
			"aesenc     %[round_keys2], %%xmm15;"
			"aesenc     %[round_keys3], %%xmm15;"
			"aesenc     %[round_keys4], %%xmm15;"
			"aesenc     %[round_keys5], %%xmm15;"
			"aesenc     %[round_keys6], %%xmm15;"
			"aesenc     %[round_keys7], %%xmm15;"
			"aesenc     %[round_keys8], %%xmm15;"
			"aesenc     %[round_keys9], %%xmm15;"
			"aesenclast %[round_keysa], %%xmm15;"
			"vmovq      %%xmm15,        %[output]"
			: [output] "=irm" (output)
			: [input] "irm" (x),
			[round_keys0] "m" (rks[0]),
			[round_keys1] "m" (rks[1]),
			[round_keys2] "m" (rks[2]),
			[round_keys3] "m" (rks[3]),
			[round_keys4] "m" (rks[4]),
			[round_keys5] "m" (rks[5]),
			[round_keys6] "m" (rks[6]),
			[round_keys7] "m" (rks[7]),
			[round_keys8] "m" (rks[8]),
			[round_keys9] "m" (rks[9]),
			[round_keysa] "m" (rks[10])
				 : "xmm15"
					 );

	return output;
}

void shuffle(__uint128_t *array, uint64_t n)
{
	if (n > 1)
	{
		uint64_t i;
		for (i = 0; i < n - 1; i++) 
		{
			uint64_t j = i + rand() / (RAND_MAX / (n - i) + 1);
			__uint128_t t = array[j];
			array[j] = array[i];
			array[i] = t;
		}
	}
}

void quick_sort (__uint128_t *a, int n) {
	int i, j, p, t;
	if (n < 2)
		return;
	p = a[n / 2];
	for (i = 0, j = n - 1;; i++, j--) {
		while (a[i] < p)
			i++;
		while (p < a[j])
			j--;
		if (i >= j)
			break;
		t = a[i];
		a[i] = a[j];
		a[j] = t;
	}
	quick_sort(a, i);
	quick_sort(a + i, n - i);
}

static __uint128_t* zipf_gen(long N, long gencount, double s) {
	int i;
	uint32_t *counts;
	__uint128_t *elems;
	struct timeval a,b,c;
	printf("Generating %ld elements in universe of %ld items with characteristic exponent %f\n",
				 gencount, N, s);
	gettimeofday(&a, NULL);
	ZIPFIAN z = create_zipfian(1, N, RFUN);
	counts = (uint32_t *)calloc(N, sizeof(counts));
	elems = (__uint128_t *)calloc(gencount, sizeof(elems));

	gettimeofday(&b, NULL);
	printf("Setup time    = %0.6fs\n", tdiff(&a, &b));
	for (i=0; i<gencount; i++) {
		long g = zipfian_gen(z);
		assert(0<=g && g<N);
		counts[g]++;
		elems[i] = g;
	}
	gettimeofday(&c, NULL);
	double rtime = tdiff(&b, &c);
	printf("Generate time = %0.6fs (%f per second)\n", rtime, gencount/rtime);
	if (0) {
		for (i=0; i<N; i++) {
			printf("%4.1f (%4.1f)\n", counts[0]/(double)counts[i], i/(counts[0]/(double)counts[i]));
			//	printf("%d ", counts[i]);
		}
		printf("\n");
	}
	destroy_zipfian(z);
	return elems;
}

typedef void * (*rand_init)(uint64_t maxoutputs, __uint128_t maxvalue, void *params);
typedef int (*gen_rand)(void *state, uint64_t noutputs, __uint128_t *outputs);
typedef void * (*duplicate_rand)(void *state);
typedef int (*gen_rand_exclusive)(void *state, uint64_t index, uint64_t noutputs, __uint128_t *outputs);

typedef int (*init_op)(QF *qf, uint64_t nvals, uint64_t num_hash_bits);
typedef bool (*insert_op)(QF *qf, __uint128_t val, uint64_t count, bool lock, bool spin);
typedef int (*lookup_op)(QF *qf, __uint128_t val);
typedef __uint128_t (*get_range_op)(QF *qf);
typedef int (*destroy_op)(QF *qf);
typedef int (*reset_op)(QF *qf);
typedef int (*iterator_op)(QF *qf, QFi *qfi, uint64_t pos);
typedef int (*iterator_get_op)(QFi *qfi, uint64_t *key, uint64_t *value, uint64_t *count);
typedef int (*iterator_next_op)(QFi *qfi);
typedef int (*iterator_end_op)(QFi *qfi);
typedef int (*get_stats_op)(QF *qf, uint64_t *distinct_elts, uint64_t *total_elts);

typedef struct rand_generator {
	rand_init init;
	gen_rand gen;
	duplicate_rand dup;
	gen_rand_exclusive gen_exc;
} rand_generator;

typedef struct filter {
	init_op init;
	insert_op insert;
	lookup_op lookup;
	get_range_op range;
	destroy_op destroy;
	reset_op reset;
	iterator_op iterator;
	iterator_get_op get;
	iterator_next_op next;
	iterator_end_op end;
	get_stats_op get_stats;
} filter;

typedef struct insert_args {
	QF qf;
	filter filter_ds;
	__uint128_t *vals;
	uint64_t cnt;
} insert_args;

typedef struct uniform_pregen_state {
	uint64_t maxoutputs;
	uint64_t nextoutput;
	__uint128_t *outputs;
} uniform_pregen_state;

typedef struct uniform_pregen_sort_state {
	uint64_t maxoutputs;
	uint64_t nextoutput;
	__uint128_t *outputs;
} uniform_pregen_sort_state;

typedef struct custom_params {
	uint64_t qbits;
	double load_factor;
} custom_params;

typedef struct custom_pregen_state {
	custom_params *params;
	uint64_t maxoutputs;
	uint64_t nextoutput;
	__uint128_t *outputs;
} custom_pregen_state;

typedef struct uniform_online_state {
	uint64_t maxoutputs;
	uint64_t maxvalue;
	unsigned int seed;
	char *buf;
	int STATELEN;
	struct random_data *rand_state;
} uniform_online_state;

typedef struct zipf_params {
	double exp;
	long universe;
	long sample;
} zipf_params;

typedef struct zipfian_pregen_state {
	zipf_params *params;
	uint64_t maxoutputs;
	uint64_t nextoutput;
	__uint128_t *outputs;
} zipfian_pregen_state;

typedef struct app_params {
	char *ip_file;
	int num;
} app_params;

typedef struct app_pregen_state {
	app_params *params;
	uint64_t maxoutputs;
	uint64_t nextoutput;
	__uint128_t *outputs;
} app_pregen_state;

__uint128_t *app_file_read(char *ip_file, int num)
{
	int i = 0, ch;
	__uint128_t *vals = (__uint128_t*)malloc(sizeof(__uint128_t)*num);
	FILE * input_values;
	
	input_values = fopen(ip_file,"r");
	if (input_values == NULL) {
		fprintf(stderr, "Error! Could not open file.\n");
	}

	ch = fscanf(input_values, "%ld", (uint64_t *)&vals[i++]);
	while (ch != EOF) {
		ch = fscanf(input_values, "%ld", (uint64_t *)&vals[i]);
		i++;
	}

	fclose(input_values);
	return vals;
}

void *app_pregen_init(uint64_t maxoutputs, __uint128_t maxvalue, void *params)
{
	uint32_t i;
	app_pregen_state *state = (app_pregen_state *)malloc(sizeof(app_pregen_state));
	assert(state != NULL);

	state->maxoutputs = maxoutputs;
	state->nextoutput = 0;
	state->params = (app_params *)params;
	{
		struct timeval tv;
		gettimeofday(&tv, NULL);
		RSEED(tv.tv_sec + tv.tv_usec);
	}
	state->outputs = app_file_read(state->params->ip_file, state->params->num);
	assert(state->outputs != NULL);
	for (i = 0; i < state->params->num; i++)
		state->outputs[i] = (1 * state->outputs[i]) % maxvalue;
	shuffle(state->outputs, state->params->num);

	return (void *)state;
}

int app_pregen_gen_rand(void *_state, uint64_t noutputs, __uint128_t *outputs)
{
	app_pregen_state *state = (app_pregen_state *)_state;
	assert(state->nextoutput + noutputs <= state->maxoutputs);
	memcpy(outputs, state->outputs+state->nextoutput, noutputs * sizeof(*state->outputs));
	state->nextoutput += noutputs;
	return noutputs;
}

int app_pregen_gen_rand_exclusive(void *_state, uint64_t index, uint64_t noutputs, __uint128_t *outputs)
{
	app_pregen_state *state = (app_pregen_state *)_state;
	assert(index + noutputs <= state->maxoutputs);
	memcpy(outputs, state->outputs + index, noutputs * sizeof(*state->outputs));
	return noutputs;
}

void *app_pregen_duplicate(void *state)
{
	app_pregen_state *newstate = (app_pregen_state *)malloc(sizeof(*newstate));
	assert(newstate);
	memcpy(newstate, state, sizeof(*newstate));
	return newstate;
}

void *zipfian_pregen_init(uint64_t maxoutputs, __uint128_t maxvalue, void *params)
{
	uint32_t i;
	zipfian_pregen_state *state = (zipfian_pregen_state *)malloc(sizeof(zipfian_pregen_state));
	assert(state != NULL);

	state->maxoutputs = maxoutputs;
	state->nextoutput = 0;
	state->params = (zipf_params*)params;
	{
		struct timeval tv;
		gettimeofday(&tv, NULL);
		RSEED(tv.tv_sec + tv.tv_usec);
	}
	state->outputs = zipf_gen(state->params->universe, state->params->sample, state->params->exp);
	assert(state->outputs != NULL);
	for (i = 0; i < state->maxoutputs; i++)
		state->outputs[i] = aes_hash2(state->outputs[i]) % maxvalue;

	return (void *)state;
}

int zipfian_pregen_gen_rand(void *_state, uint64_t noutputs, __uint128_t *outputs)
{
	zipfian_pregen_state *state = (zipfian_pregen_state *)_state;
	assert(state->nextoutput + noutputs <= state->maxoutputs);
	memcpy(outputs, state->outputs+state->nextoutput, noutputs * sizeof(*state->outputs));
	state->nextoutput += noutputs;
	return noutputs;
}

int zipfian_pregen_gen_rand_exclusive(void *_state, uint64_t index, uint64_t noutputs, __uint128_t *outputs)
{
	zipfian_pregen_state *state = (zipfian_pregen_state *)_state;
	assert(index + noutputs <= state->maxoutputs);
	memcpy(outputs, state->outputs + index, noutputs * sizeof(*state->outputs));
	return noutputs;
}

void *zipfian_pregen_duplicate(void *state)
{
	zipfian_pregen_state *newstate = (zipfian_pregen_state *)malloc(sizeof(*newstate));
	assert(newstate);
	memcpy(newstate, state, sizeof(*newstate));
	return newstate;
}

void *uniform_pregen_init(uint64_t maxoutputs, __uint128_t maxvalue, void *params)
{
	uint32_t i;
	uniform_pregen_state *state = (uniform_pregen_state *)malloc(sizeof(uniform_pregen_state));
	assert(state != NULL);

	state->nextoutput = 0;

	state->maxoutputs = maxoutputs;
	state->outputs = (__uint128_t *)malloc(state->maxoutputs * sizeof(state->outputs[0]));
	assert(state->outputs != NULL);
	RAND_pseudo_bytes((unsigned char *)state->outputs, sizeof(*state->outputs) * state->maxoutputs);
	for (i = 0; i < state->maxoutputs; i++)
		state->outputs[i] = (1 * state->outputs[i]) % maxvalue;

	return (void *)state;
}

int uniform_pregen_gen_rand(void *_state, uint64_t noutputs, __uint128_t *outputs)
{
	uniform_pregen_state *state = (uniform_pregen_state *)_state;
	assert(state->nextoutput + noutputs <= state->maxoutputs);
	memcpy(outputs, state->outputs+state->nextoutput, noutputs * sizeof(*state->outputs));
	state->nextoutput += noutputs;
	return noutputs;
}

int uniform_pregen_gen_rand_exclusive(void *_state, uint64_t index, uint64_t noutputs, __uint128_t *outputs)
{
	uniform_pregen_state *state = (uniform_pregen_state *)_state;
	assert(index + noutputs <= state->maxoutputs);
	memcpy(outputs, state->outputs + index, noutputs * sizeof(*state->outputs));
	return noutputs;
}

void *uniform_pregen_duplicate(void *state)
{
	uniform_pregen_state *newstate = (uniform_pregen_state *)malloc(sizeof(*newstate));
	assert(newstate);
	memcpy(newstate, state, sizeof(*newstate));
	return newstate;
}

void *uniform_online_init(uint64_t maxoutputs, __uint128_t maxvalue, void *params)
{
	uniform_online_state *state = (uniform_online_state *)malloc(sizeof(uniform_online_state));
	assert(state != NULL);

	state->maxoutputs = maxoutputs;
	state->maxvalue = maxvalue;
	state->seed = time(NULL);
	state->STATELEN = 256;
	state->buf = (char *)calloc(256, sizeof(char));
	state->rand_state = (struct random_data *)calloc(1, sizeof(struct random_data));

	initstate_r(state->seed, state->buf, state->STATELEN, state->rand_state);
	return (void *)state;
}

int uniform_online_gen_rand(void *_state, uint64_t noutputs, __uint128_t *outputs)
{
	uint32_t i, j;
	uniform_online_state *state = (uniform_online_state *)_state;
	assert(state->rand_state != NULL);
	memset(outputs, 0, noutputs*sizeof(__uint128_t));
	for (i = 0; i < noutputs; i++) {
		int32_t result;
		for (j = 0; j < 4; j++) {
			random_r(state->rand_state, &result);
			outputs[i] = (outputs[i] * RAND_MAX) + result;
		}
		outputs[i] = (1 * outputs[i]) % state->maxvalue;
	}
	return noutputs;
}

int uniform_online_gen_rand_exclusive(void *_state, uint64_t index, uint64_t noutputs, __uint128_t *outputs)
{
	// Exclusive mode is not implemented
	
	return 0;
}

void *uniform_online_duplicate(void *_state)
{
	uniform_online_state *newstate = (uniform_online_state *)malloc(sizeof(uniform_online_state));
	assert(newstate != NULL);
	uniform_online_state *oldstate = (uniform_online_state *)_state;

	newstate->maxvalue = oldstate->maxvalue;
	newstate->seed = oldstate->seed;
	newstate->STATELEN = oldstate->STATELEN;
	
	newstate->buf = (char *)calloc(256, sizeof(char));
	memcpy(newstate->buf, oldstate->buf, newstate->STATELEN);
	newstate->rand_state = (struct random_data *)calloc(1, sizeof(struct random_data));

	initstate_r(newstate->seed, newstate->buf, newstate->STATELEN, newstate->rand_state);
	return newstate;
}

void *custom_pregen_init(uint64_t maxoutputs, __uint128_t maxvalue, void *params)
{
	uint32_t i;
	custom_pregen_state *state = (custom_pregen_state *)malloc(sizeof(custom_pregen_state));
	assert(state != NULL);

	state->nextoutput = 0;
	state->maxoutputs = maxoutputs;
	state->params = (custom_params*)params;
	
	state->outputs = (__uint128_t *)malloc(state->maxoutputs * sizeof(state->outputs[0]));
	assert(state->outputs != NULL);
	
	RAND_pseudo_bytes((unsigned char *)state->outputs, sizeof(*state->outputs) * state->maxoutputs);
	for (i = 0; i < state->maxoutputs; i++)
		state->outputs[i] = (1 * state->outputs[i]) % maxvalue;

	uint64_t cnt = 0;
	double idx = 0;
	for (i = 0; i < state->maxoutputs; i++, idx++) {
		uint64_t item;
		if (i == 0) {
			item = 0;
		} else {
			item = ((1ULL + i) << BITS_PER_SLOT);
		}
		if (cnt == 0 || (cnt/idx) < state->params->load_factor) {
			state->outputs[cnt] = item;
			cnt++;
		}
	}

	return (void *)state;
}

int custom_pregen_gen_rand(void *_state, uint64_t noutputs, __uint128_t *outputs)
{
	custom_pregen_state *state = (custom_pregen_state *)_state;
	assert(state->nextoutput + noutputs <= state->maxoutputs);
	memcpy(outputs, state->outputs+state->nextoutput, noutputs * sizeof(*state->outputs));
	state->nextoutput += noutputs;
	return noutputs;
}

int custom_pregen_gen_rand_exclusive(void *_state, uint64_t index, uint64_t noutputs, __uint128_t *outputs)
{
	custom_pregen_state *state = (custom_pregen_state *)_state;
	assert(index + noutputs <= state->maxoutputs);
	memcpy(outputs, state->outputs + index, noutputs * sizeof(*state->outputs));
	return noutputs;
}

void *custom_pregen_duplicate(void *state)
{
	custom_pregen_state *newstate = (custom_pregen_state *)malloc(sizeof(*newstate));
	assert(newstate);
	memcpy(newstate, state, sizeof(*newstate));
	return newstate;
}

void *uniform_pregen_sort_init(uint64_t maxoutputs, __uint128_t maxvalue, void *params)
{
	uint32_t i;
	uniform_pregen_sort_state *state = (uniform_pregen_sort_state *)malloc(sizeof(uniform_pregen_sort_state));
	assert(state != NULL);

	state->nextoutput = 0;
	state->maxoutputs = maxoutputs;
	uint32_t factor = *((uint32_t*)params);

	state->outputs = (__uint128_t *)malloc(state->maxoutputs * sizeof(state->outputs[0]));
	assert(state->outputs != NULL);
	
	RAND_pseudo_bytes((unsigned char *)state->outputs, sizeof(*state->outputs) * state->maxoutputs);
	for (i = 0; i < state->maxoutputs; i++)
		state->outputs[i] = (1 * state->outputs[i]) % maxvalue;

	for (i = 0; i < factor; i++) {
		quick_sort(state->outputs+(i*(state->maxoutputs/factor)), (state->maxoutputs/factor));
	}

	//quick_sort(state->outputs, maxoutputs);
	return (void *)state;
}

int uniform_pregen_sort_gen_rand(void *_state, uint64_t noutputs, __uint128_t *outputs)
{
	uniform_pregen_sort_state *state = (uniform_pregen_sort_state *)_state;
	assert(state->nextoutput + noutputs <= state->maxoutputs);
	memcpy(outputs, state->outputs+state->nextoutput, noutputs * sizeof(*state->outputs));
	state->nextoutput += noutputs;
	return noutputs;
}

int uniform_pregen_sort_gen_rand_exclusive(void *_state, uint64_t index, uint64_t noutputs, __uint128_t *outputs)
{
	uniform_pregen_sort_state *state = (uniform_pregen_sort_state *)_state;
	assert(index + noutputs <= state->maxoutputs);
	memcpy(outputs, state->outputs + index, noutputs * sizeof(*state->outputs));
	return noutputs;
}

void *uniform_pregen_sort_duplicate(void *state)
{
	uniform_pregen_sort_state *newstate = (uniform_pregen_sort_state *)malloc(sizeof(*newstate));
	assert(newstate);
	memcpy(newstate, state, sizeof(*newstate));
	return newstate;
}


rand_generator uniform_pregen = {
	uniform_pregen_init,
	uniform_pregen_gen_rand,
	uniform_pregen_duplicate,
	uniform_pregen_gen_rand_exclusive
};

rand_generator custom_pregen = {
	custom_pregen_init,
	custom_pregen_gen_rand,
	custom_pregen_duplicate,
	custom_pregen_gen_rand_exclusive
};

rand_generator uniform_pregen_sort = {
	uniform_pregen_sort_init,
	uniform_pregen_sort_gen_rand,
	uniform_pregen_sort_duplicate,
	uniform_pregen_sort_gen_rand_exclusive
};

rand_generator uniform_online = {
	uniform_online_init,
	uniform_online_gen_rand,
	uniform_online_duplicate,
	uniform_online_gen_rand_exclusive
};

rand_generator zipfian_pregen = {
	zipfian_pregen_init,
	zipfian_pregen_gen_rand,
	zipfian_pregen_duplicate,
	zipfian_pregen_gen_rand_exclusive
};

rand_generator app_pregen = {
	app_pregen_init,
	app_pregen_gen_rand,
	app_pregen_duplicate,
	app_pregen_gen_rand_exclusive
};

//filter qf = {
//	qf_initialize,
//	qf_insert,
//	qf_lookup,
//	qf_range,
//	qf_destroy_wrap
//};

filter gqf = {
	gqf_init,
	gqf_insert,
	gqf_lookup,
	gqf_range,
	gqf_destroy,
	gqf_reset,
	gqf_iterator,
	gqf_get,
	gqf_next,
	gqf_end,
	gqf_get_stats
};

//filter cf = {
//	cf_init,
//	cf_insert,
//	cf_lookup,
//	cf_range,
//	cf_destroy
//};
//
//filter bf = {
//	bf_init,
//	bf_insert,
//	bf_lookup,
//	bf_range,
//	bf_destroy
//};

void *insert_bm(void *arg)
{
	static int count;
	filter ds = gqf;
	QF local_qf;
	QFi local_qfi;

	ds.init(&local_qf, 16, 34);
	insert_args *args = (insert_args *)arg;
	for (uint64_t i = 0; i < args->cnt; i++) {
		if (!args->filter_ds.insert(&args->qf, args->vals[i], 1, true, false)) {
			args->filter_ds.insert(&local_qf, args->vals[i], 1, false, false);
				count++;
			// check of the load factor of the local QF is more
			// than 50%
			if (count > 1<<(15)) {
				ds.iterator(&local_qf, &local_qfi, 0);
				do {
					uint64_t key = 0, value = 0, count = 0;
					ds.get(&local_qfi, &key, &value, &count);
					ds.insert(&args->qf, key, count, true, true);
				} while (!ds.next(&local_qfi));
				count = 0;
				ds.reset(&local_qf);
			}
		}
	}
	return NULL;
}

void multi_threaded_insertion(insert_args args[], int tcnt)
{
	pthread_t threads[tcnt];

	for (int i = 0; i < tcnt; i++) {
		if (pthread_create(&threads[i], NULL, &insert_bm, &args[i])) {
			fprintf(stderr, "Error creating thread\n");
			exit(0);
		}
	}

	for (int i = 0; i < tcnt; i++) {
		if (pthread_join(threads[i], NULL)) {
			fprintf(stderr, "Error joining thread\n");
			exit(0);
		}
	}
}


uint64_t tv2msec(struct timeval tv)
{
	return tv.tv_sec * 1000 + tv.tv_usec / 1000;
}

int cmp_uint64_t(const void *a, const void *b)
{
	const uint64_t *ua = (const uint64_t*)a, *ub = (const uint64_t *)b;
	return *ua < *ub ? -1 : *ua == *ub ? 0 : 1;
}

void usage(char *name)
{
	printf("%s [OPTIONS]\n"
				 "Options are:\n"
				 "  -n nslots     [ log_2 of filter capacity.  Default 24 ]\n"
				 "  -r nruns      [ number of runs.  Default 1 ]\n"
				 "  -p npoints    [ number of points on the graph.  Default 20 ]\n"
				 "  -m randmode   [ Data distribution, one of \n"
				 "                    uniform_pregen\n"
				 "                    uniform_online\n"
				 "                    zipfian_pregen\n"
				 "                    custom_pregen\n"
				 "                    uniform_pregen_sort\n"
				 "                    app_pregen\n"
				 "                  Default uniform_pregen ]\n"
				 "  -d datastruct  [ Default qf. ]\n"
				 "  -f outputfile  [ Default qf. ]\n"
				 "  -t number of threads  [ Should be 1 or above for the experiment. ]\n"
				 "  -i input file for app specific benchmark [Optional]\n"
				 "  -v num of values in the input file [Optional]\n"
				 "  -l load factor for even distribution  [ Default 0.5 ] [Optional]\n"
				 "  -u universe for zipfian distribution  [ Default nvals ] [Optional]\n"
				 "  -s constant for zipfian distribution  [ Default 1.5 ] [Optional]\n"
				 "  -l load factor for even distribution  [ Default 0.5 ] [Optional]\n"
				 "  -a number of parts for sorted input  [ Default 5 ] [Optional]\n",
				 name);
}

int main(int argc, char **argv)
{
	uint32_t nbits = 0, nruns = 0, factor = 5;
	unsigned int npoints = 0;
	int nthreads = 0;
	uint64_t nslots = 0, nvals = 0;
	double s = 1.5, load_factor = 0; long universe = 0;
	int numvals = 0;
	char *randmode = "uniform_pregen";
	char *datastruct = "qf";
	char *outputfile = "qf";
	char *inputfile = "qf";
	void *param = NULL;

	QF qf;
	QFi qfi;
	filter filter_ds;
	rand_generator *vals_gen;
	void *vals_gen_state;
	void *old_vals_gen_state;
	rand_generator *othervals_gen;
	void *othervals_gen_state;

	unsigned int i, j, exp, run;
	struct timeval tv_insert[100][1];
	struct timeval tv_exit_lookup[100][1];
	struct timeval tv_false_lookup[100][1];
	uint64_t fps = 0;

	const char *dir = "../vldb16/data/";
	const char *insert_op = "-insert.txt\0";
	const char *exit_lookup_op = "-exists-lookup.txt\0";
	const char *false_lookup_op = "-false-lookup.txt\0";
	char filename_insert[256];
	char filename_exit_lookup[256];
	char filename_false_lookup[256];

	/* Argument parsing */
	int opt;
	char *term;

	while((opt = getopt(argc, argv, "n:r:p:m:d:f:t:i:v:s:u:l:a:")) != -1) {
		switch(opt) {
			case 'n':
				nbits = strtol(optarg, &term, 10);
				if (*term) {
					fprintf(stderr, "Argument to -n must be an integer\n");
					usage(argv[0]);
					exit(1);
				}
				nslots = (1ULL << nbits);
				nvals = 950*nslots/1000;
				universe = nvals;
				break;
			case 'r':
				nruns = strtol(optarg, &term, 10);
				if (*term) {
					fprintf(stderr, "Argument to -r must be an integer\n");
					usage(argv[0]);
					exit(1);
				}
				break;
			case 'p':
				npoints = strtol(optarg, &term, 10);
				if (*term) {
					fprintf(stderr, "Argument to -p must be an integer\n");
					usage(argv[0]);
					exit(1);
				}
				break;
			case 'm':
				randmode = optarg;
				break;
			case 'd':
				datastruct = optarg;
				break;
			case 'f':
				outputfile = optarg;
				break;
			case 't':
				nthreads = strtol(optarg, &term, 10);
				if (*term) {
					fprintf(stderr, "Argument to -t must be an integer\n");
					usage(argv[0]);
					exit(1);
				}
				break;
			case 'i':
				inputfile = optarg;
				break;
			case 'v':
				numvals = (int)strtol(optarg, &term, 10);
				break;
			case 's':
				s = strtod(optarg, NULL);
				break;
			case 'u':
				universe = strtol(optarg, &term, 10);
				break;
			case 'l':
				load_factor = strtod(optarg, NULL);
				break;
			case 'a':
				factor = strtol(optarg, &term, 10);
				break;
			default:
				fprintf(stderr, "Unknown option\n");
				usage(argv[0]);
				exit(1);
				break;
		}
	}

	if (strcmp(randmode, "uniform_pregen") == 0) {
		vals_gen = &uniform_pregen;
		othervals_gen = &uniform_pregen;
	} else if (strcmp(randmode, "uniform_pregen_sort") == 0) {
		vals_gen = &uniform_pregen_sort;
		othervals_gen = &uniform_pregen_sort;
		param = &factor;
	} else if (strcmp(randmode, "uniform_online") == 0) {
		vals_gen = &uniform_online;
		othervals_gen = &uniform_online;
	} else if (strcmp(randmode, "custom_pregen") == 0) {
		vals_gen = &custom_pregen;
		othervals_gen = &custom_pregen;
		param = (custom_params* )malloc(sizeof(custom_params));
		assert(param != NULL);
		((custom_params*)param)->load_factor = load_factor;
		((custom_params*)param)->qbits = nbits;
	} else if (strcmp(randmode, "zipfian_pregen") == 0) {
		vals_gen = &zipfian_pregen;
		othervals_gen = &uniform_pregen;
		param = (zipf_params *)malloc(sizeof(zipf_params));
		assert(param != NULL);
		if (s == 0 || universe == 0) {
			fprintf(stderr, "Unknown randmode.\n");
			usage(argv[0]);
			exit(1);
		}
		((zipf_params *)param)->exp = s;
		((zipf_params *)param)->universe = universe;
		((zipf_params *)param)->sample = nvals;
	} else if (strcmp(randmode, "app_pregen") == 0) {
		vals_gen = &app_pregen;
		othervals_gen = &app_pregen;
		param = (app_params *)malloc(sizeof(app_params));
		((app_params *)param)->ip_file = inputfile;
		((app_params *)param)->num = numvals;
		nvals = numvals;
	} else {
		fprintf(stderr, "Unknown randmode.\n");
		usage(argv[0]);
		exit(1);
	}

	if (strcmp(datastruct, "gqf") == 0) {
		filter_ds = gqf;
//	} else if (strcmp(datastruct, "qf") == 0) {
//		filter_ds = qf;
//	} else if (strcmp(datastruct, "cf") == 0) {
//		filter_ds = cf;
//	} else if (strcmp(datastruct, "bf") == 0) {
//		filter_ds = bf;
	} else {
		fprintf(stderr, "Unknown randmode.\n");
		usage(argv[0]);
		exit(1);
	}

	snprintf(filename_insert, strlen(dir) + strlen(outputfile) + strlen(insert_op) + 1, "%s%s%s", dir, outputfile, insert_op);
	snprintf(filename_exit_lookup, strlen(dir) + strlen(outputfile) + strlen(exit_lookup_op) + 1, "%s%s%s", dir, outputfile, exit_lookup_op);

	snprintf(filename_false_lookup, strlen(dir) + strlen(outputfile) + strlen(false_lookup_op) + 1, "%s%s%s", dir, outputfile, false_lookup_op);

	FILE *fp_insert = fopen(filename_insert, "w");
	FILE *fp_exit_lookup = fopen(filename_exit_lookup, "w");
	FILE *fp_false_lookup = fopen(filename_false_lookup, "w");

	if (fp_insert == NULL || fp_exit_lookup == NULL || fp_false_lookup == NULL) {
		printf("Can't open the data file");
		exit(1);
	}

	if (nthreads > 0) {
		filter_ds.init(&qf, nbits, nbits + 8);
		__uint128_t *vals[nthreads];
		insert_args args[nthreads];
		uint64_t nelts, ndistinct_elts;
		uint64_t idx = 0;

		vals_gen_state = vals_gen->init(nvals, filter_ds.range(&qf), param);

		for (int i = 0; i < nthreads; i++, idx += numvals/nthreads) {
			vals[i] = (__uint128_t *)malloc((nvals/nthreads)*sizeof(__uint128_t));
			args[i].qf = qf;
			args[i].filter_ds = filter_ds;
			assert(vals_gen->gen_exc(vals_gen_state, idx, numvals/nthreads, vals[i]) == numvals/nthreads);
			args[i].vals = vals[i];
			args[i].cnt = numvals/nthreads;
		}

		gettimeofday(&tv_insert[0][0], NULL);
		multi_threaded_insertion(args, nthreads);
		gettimeofday(&tv_insert[1][0], NULL);

		printf("Insert Performance:\n");
		printf(" %f",
					 0.001 * numvals/(tv2msec(tv_insert[1][0]) - tv2msec(tv_insert[0][0])));
		printf(" Million inserts per second\n");

		uint64_t max_cnt = 0;
		filter_ds.iterator(&qf, &qfi, 0);
		do {
			uint64_t key = 0, value = 0, count = 0;
			filter_ds.get(&qfi, &key, &value, &count);
			//freq_file << key << " " << count << endl;
			if (max_cnt < count)
				max_cnt = count;
		} while (!filter_ds.next(&qfi));

		filter_ds.get_stats(&qf, &ndistinct_elts, &nelts);
		printf("Num distinct elts: %ld\n", ndistinct_elts);
		printf("Max count: %ld\n", max_cnt);
		printf("Num elts: %ld\n", nelts);
	} else {
		for (run = 0; run < nruns; run++) {
			fps = 0;
			filter_ds.init(&qf, nbits, nbits + 8);

			vals_gen_state = vals_gen->init(nvals, filter_ds.range(&qf), param);
			old_vals_gen_state = vals_gen->dup(vals_gen_state);
			sleep(5);
			othervals_gen_state = othervals_gen->init(nvals, filter_ds.range(&qf), param);

			for (exp = 0; exp < 2*npoints; exp += 2) {
				i = (exp/2)*(nvals/npoints);
				j = ((exp/2) + 1)*(nvals/npoints);
				printf("Round: %d\n", exp/2);

				gettimeofday(&tv_insert[exp][run], NULL);
				for (;i < j; i += 1<<16) {
					int nitems = j - i < 1<<16 ? j - i : 1<<16;
					__uint128_t vals[1<<16];
					int m;
					assert(vals_gen->gen(vals_gen_state, nitems, vals) == nitems);

					for (m = 0; m < nitems; m++) {
						filter_ds.insert(&qf, vals[m], 1, 0, 0);
					}
				}
				gettimeofday(&tv_insert[exp+1][run], NULL);

				i = (exp/2)*(nvals/20);
				gettimeofday(&tv_exit_lookup[exp][run], NULL);
				for (;i < j; i += 1<<16) {
					int nitems = j - i < 1<<16 ? j - i : 1<<16;
					__uint128_t vals[1<<16];
					int m;
					assert(vals_gen->gen(old_vals_gen_state, nitems, vals) == nitems);
					for (m = 0; m < nitems; m++) {
						if (!filter_ds.lookup(&qf, vals[m])) {
							fprintf(stderr,
											"Failed lookup for 0x%lx%016lx\n",
											(uint64_t)(vals[m]>>64),
											(uint64_t)(vals[m] & 0xffffffffffffffff));
							abort();
						}
					}
				}
				gettimeofday(&tv_exit_lookup[exp+1][run], NULL);

				i = (exp/2)*(nvals/20);
				gettimeofday(&tv_false_lookup[exp][run], NULL);
				for (;i < j; i += 1<<16) {
					int nitems = j - i < 1<<16 ? j - i : 1<<16;
					__uint128_t othervals[1<<16];
					int m;
					assert(othervals_gen->gen(othervals_gen_state, nitems, othervals) == nitems);
					for (m = 0; m < nitems; m++) {
						fps += filter_ds.lookup(&qf, othervals[m]);
					}
				}
				gettimeofday(&tv_false_lookup[exp+1][run], NULL);
			}
			filter_ds.destroy(&qf);
		}
		printf("Wiring results to file: %s\n", filename_insert);
		fprintf(fp_insert, "x_0");
		for (run = 0; run < nruns; run++) {
			fprintf(fp_insert, "    y_%d", run);
		}
		fprintf(fp_insert, "\n");
		for (exp = 0; exp < 2*npoints; exp += 2) {
			fprintf(fp_insert, "%d", ((exp/2)*(100/npoints)));
			for (run = 0; run < nruns; run++) {
				fprintf(fp_insert, " %f",
								0.001 * (nvals/npoints)/(tv2msec(tv_insert[exp+1][run]) - tv2msec(tv_insert[exp][run])));
			}
			fprintf(fp_insert, "\n");
		}
		printf("Insert Performance written\n");

		printf("Wiring results to file: %s\n", filename_exit_lookup);
		fprintf(fp_exit_lookup, "x_0");
		for (run = 0; run < nruns; run++) {
			fprintf(fp_exit_lookup, "    y_%d", run);
		}
		fprintf(fp_exit_lookup, "\n");
		for (exp = 0; exp < 2*npoints; exp += 2) {
			fprintf(fp_exit_lookup, "%d", ((exp/2)*(100/npoints)));
			for (run = 0; run < nruns; run++) {
				fprintf(fp_exit_lookup, " %f",
								0.001 * (nvals/npoints)/(tv2msec(tv_exit_lookup[exp+1][run]) - tv2msec(tv_exit_lookup[exp][run])));
			}
			fprintf(fp_exit_lookup, "\n");
		}
		printf("Existing Lookup Performance written\n");

		printf("Wiring results to file: %s\n", filename_false_lookup);
		fprintf(fp_false_lookup, "x_0");
		for (run = 0; run < nruns; run++) {
			fprintf(fp_false_lookup, "    y_%d", run);
		}
		fprintf(fp_false_lookup, "\n");
		for (exp = 0; exp < 2*npoints; exp += 2) {
			fprintf(fp_false_lookup, "%d", ((exp/2)*(100/npoints)));
			for (run = 0; run < nruns; run++) {
				fprintf(fp_false_lookup, " %f",
								0.001 * (nvals/npoints)/(tv2msec(tv_false_lookup[exp+1][run]) - tv2msec(tv_false_lookup[exp][run])));
			}
			fprintf(fp_false_lookup, "\n");
		}
		printf("False Lookup Performance written\n");

		printf("FP rate: %f (%lu/%lu)\n", 1.0 * fps / nvals, fps, nvals);
	}
	
	fclose(fp_insert);
	fclose(fp_exit_lookup);
	fclose(fp_false_lookup);

	return 0;
}
